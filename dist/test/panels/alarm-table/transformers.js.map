{"version":3,"sources":["../../../../src/panels/alarm-table/transformers.js"],"names":["transformers","description","getColumns","data","length","columns","forEach","table","push","shift","filter","v","every","a","indexOf","transformTable","columnsToInclude","model","cellsByColumnIndex","each","rows","i","row","cellsByPanelColumnIndex","j","colDef","idx","findIndex","col","text","message","JSON","stringify","k","l","meta","undefined","mergeTables","tables","concat","uniqBy","alarm","source","alarmId","id","transform","panel","transformedTables","dat","type","mergedTables","transformDataToTable","transformer"],"mappings":"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","file":"transformers.js","sourcesContent":["import _ from 'lodash';\nimport {TableModel} from './table_model';\n\nlet transformers = {};\n\ntransformers['table'] = {\n  description: 'Table',\n  getColumns: function(data) {\n    if (!data || data.length === 0) {\n      return [];\n    }\n\n    // Create a list containing the column names from each table\n    let columns = [];\n    _.forEach(data, (table) => {\n      columns.push(table.columns);\n    });\n    // Return the intersection of all column names only returning\n    // those that are present in each table\n    // NOTE: _.intersection([array]) should work here, but appears to be broken\n    return columns.shift().filter(function(v) {\n      return columns.every(function(a) {\n        return a.indexOf(v) !== -1;\n      });\n    });\n  },\n\n  transformTable: function(data, columnsToInclude) {\n    let model = new TableModel();\n\n    // Convert the rows to columns\n    let cellsByColumnIndex = [];\n    _.each(data.columns, col => cellsByColumnIndex.push([]));\n\n    // For every row\n    _.each(data.rows, row => {\n      // And every cell in the row\n      for (let i = 0; i < row.length; i++) {\n        // Append the cell to the appropriate column list\n        cellsByColumnIndex[i].push(row[i]);\n      }\n    });\n\n    // Now reorder the columns according the list of columns in the panel definition\n    let cellsByPanelColumnIndex = [];\n    for (let j = 0; j < columnsToInclude.length; j++) {\n      let colDef = columnsToInclude[j];\n      // Determine the column's index in the given data\n      let idx = _.findIndex(data.columns, col => {\n        return col === colDef.text || col.text === colDef.text;\n      });\n      if (idx < 0) {\n        throw {message: 'The column named \"' + colDef.text + '\" was specified in the panel definition,' +\n        ' but was not found in the given data. The available columns include: ' + JSON.stringify(data.columns)};\n      }\n      // Re-order\n      cellsByPanelColumnIndex[j] = cellsByColumnIndex[idx];\n    }\n\n    // Convert the columns back to rows\n    model.columns = columnsToInclude;\n    model.rows = [];\n    for (let k = 0; k < cellsByPanelColumnIndex[0].length; k++) {\n      let row = [];\n      for (let l = 0; l < columnsToInclude.length; l++) {\n        row.push(cellsByPanelColumnIndex[l][k]);\n      }\n      // Preserve the meta-data, if any\n      if (data.rows[k].meta !== undefined) {\n        row.meta = data.rows[k].meta;\n      }\n      model.rows.push(row);\n    }\n    return model;\n  },\n\n  mergeTables: function(tables) {\n    let model = new TableModel();\n    // Use the list of columns from the first table:\n    //  transformTable() will ensure that all tables have the same columns\n    model.columns = tables[0].columns;\n    // Concatenate the rows\n    _.each(tables, table => {\n      model.rows = _.concat(model.rows, table.rows);\n    });\n    // De-duplicate by (source, alarm.id) tuple\n    model.rows = _.uniqBy(model.rows, row => {\n      if (row.meta && row.meta.alarm) {\n        return JSON.stringify({\n          source: row.meta.source,\n          alarmId: row.meta.alarm.id\n        });\n      } else {\n        return row;\n      }\n    });\n    return model;\n  },\n\n  transform: function(data, panel, model) {\n    if (!data || data.length === 0) {\n      return;\n    }\n\n    // Determine the list of columns to include\n    let columnsToInclude = [];\n    if (panel.columns && panel.columns.length > 0) {\n      // One or more columns were specified in the column definition, use these\n      columnsToInclude = panel.columns;\n    } else {\n      // Use all the available columns\n      columnsToInclude = this.getColumns(data);\n    }\n\n    // Transform each of the datasource results individually\n    let transformedTables = [];\n    _.each(data, (dat) => {\n      if (dat.type !== 'table') {\n        throw {message: 'Query result is not in table format, try using another transform.'};\n      }\n      transformedTables.push(this.transformTable(dat, columnsToInclude));\n    });\n\n    // Merge the results and update the model\n    let mergedTables = this.mergeTables(transformedTables);\n    model.columns = mergedTables.columns;\n    model.rows = mergedTables.rows;\n  }\n};\n\nfunction transformDataToTable(data, panel) {\n  let model = new TableModel();\n\n  if (!data || data.length === 0) {\n    return model;\n  }\n\n  let transformer = transformers[panel.transform];\n  if (!transformer) {\n    throw {message: 'Transformer ' + panel.transform + ' not found'};\n  }\n\n  transformer.transform(data, panel, model);\n  return model;\n}\n\nexport {transformers, transformDataToTable};\n"]}