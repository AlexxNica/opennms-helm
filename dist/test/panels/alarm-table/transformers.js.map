{"version":3,"sources":["../../../../src/panels/alarm-table/transformers.js"],"names":["transformers","description","getColumns","data","length","columns","forEach","table","push","shift","filter","v","every","a","indexOf","transformTable","columnsToInclude","model","cellsByColumnIndex","each","rows","i","row","emptyColumn","Array","cellsByPanelColumnIndex","j","colDef","idx","findIndex","col","text","k","l","meta","undefined","mergeTables","tables","concat","uniqBy","alarm","JSON","stringify","source","alarmId","id","transform","panel","transformedTables","dat","type","message","mergedTables","transformDataToTable","transformer"],"mappings":"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","file":"transformers.js","sourcesContent":["import _ from 'lodash';\nimport {TableModel} from './table_model';\n\nlet transformers = {};\n\ntransformers['table'] = {\n  description: 'Table',\n  getColumns: function(data) {\n    if (!data || data.length === 0) {\n      return [];\n    }\n\n    // Create a list containing the column names from each table\n    let columns = [];\n    _.forEach(data, (table) => {\n      columns.push(table.columns);\n    });\n    // Return the intersection of all column names only returning\n    // those that are present in each table\n    // NOTE: _.intersection([array]) should work here, but appears to be broken\n    return columns.shift().filter(function(v) {\n      return columns.every(function(a) {\n        return a.indexOf(v) !== -1;\n      });\n    });\n  },\n\n  transformTable: function(data, columnsToInclude) {\n    let model = new TableModel();\n\n    // Convert the rows to columns\n    let cellsByColumnIndex = [];\n    _.each(data.columns, col => cellsByColumnIndex.push([]));\n\n    // For every row\n    _.each(data.rows, row => {\n      // And every cell in the row\n      for (let i = 0; i < row.length; i++) {\n        // Append the cell to the appropriate column list\n        cellsByColumnIndex[i].push(row[i]);\n      }\n    });\n\n    // Used when no matching column is found\n    let emptyColumn = new Array(data.rows.length);\n\n    // Now reorder the columns according the list of columns in the panel definition\n    let cellsByPanelColumnIndex = [];\n    for (let j = 0; j < columnsToInclude.length; j++) {\n      let colDef = columnsToInclude[j];\n      // Determine the column's index in the given data\n      let idx = _.findIndex(data.columns, col => {\n        return col === colDef.text || col.text === colDef.text;\n      });\n      if (idx < 0) {\n        // The column does not exist\n        cellsByPanelColumnIndex[j] = emptyColumn;\n        continue;\n      }\n      // Re-order\n      cellsByPanelColumnIndex[j] = cellsByColumnIndex[idx];\n    }\n\n    // Convert the columns back to rows\n    model.columns = columnsToInclude;\n    model.rows = [];\n    for (let k = 0; k < cellsByPanelColumnIndex[0].length; k++) {\n      let row = [];\n      for (let l = 0; l < columnsToInclude.length; l++) {\n        row.push(cellsByPanelColumnIndex[l][k]);\n      }\n      // Preserve the meta-data, if any\n      if (data.rows[k].meta !== undefined) {\n        row.meta = data.rows[k].meta;\n      }\n      model.rows.push(row);\n    }\n    return model;\n  },\n\n  mergeTables: function(tables) {\n    let model = new TableModel();\n    // Use the list of columns from the first table:\n    //  transformTable() will ensure that all tables have the same columns\n    model.columns = tables[0].columns;\n    // Concatenate the rows\n    _.each(tables, table => {\n      model.rows = _.concat(model.rows, table.rows);\n    });\n    // De-duplicate by (source, alarm.id) tuple\n    model.rows = _.uniqBy(model.rows, row => {\n      if (row.meta && row.meta.alarm) {\n        return JSON.stringify({\n          source: row.meta.source,\n          alarmId: row.meta.alarm.id\n        });\n      } else {\n        return row;\n      }\n    });\n    return model;\n  },\n\n  transform: function(data, panel, model) {\n    if (!data || data.length === 0) {\n      return;\n    }\n\n    // Determine the list of columns to include\n    let columnsToInclude = [];\n    if (panel.columns && panel.columns.length > 0) {\n      // One or more columns were specified in the column definition, use these\n      columnsToInclude = panel.columns;\n    } else {\n      // Use all the available columns\n      columnsToInclude = this.getColumns(data);\n    }\n\n    // Transform each of the datasource results individually\n    let transformedTables = [];\n    _.each(data, (dat) => {\n      if (dat.type !== 'table') {\n        throw {message: 'Query result is not in table format, try using another transform.'};\n      }\n      transformedTables.push(this.transformTable(dat, columnsToInclude));\n    });\n\n    // Merge the results and update the model\n    let mergedTables = this.mergeTables(transformedTables);\n    model.columns = mergedTables.columns;\n    model.rows = mergedTables.rows;\n  }\n};\n\nfunction transformDataToTable(data, panel) {\n  let model = new TableModel();\n\n  if (!data || data.length === 0) {\n    return model;\n  }\n\n  let transformer = transformers[panel.transform];\n  if (!transformer) {\n    throw {message: 'Transformer ' + panel.transform + ' not found'};\n  }\n\n  transformer.transform(data, panel, model);\n  return model;\n}\n\nexport {transformers, transformDataToTable};\n"]}