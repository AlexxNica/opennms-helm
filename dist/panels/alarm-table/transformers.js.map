{"version":3,"sources":["../../../src/panels/alarm-table/transformers.js"],"names":["transformDataToTable","data","panel","model","TableModel","length","transformer","transformers","transform","message","_","description","getColumns","columns","forEach","table","push","shift","filter","v","every","a","indexOf","transformTable","columnsToInclude","cellsByColumnIndex","each","rows","i","row","cellsByPanelColumnIndex","j","colDef","idx","findIndex","col","text","JSON","stringify","k","l","meta","undefined","mergeTables","tables","concat","uniqBy","alarm","source","alarmId","id","transformedTables","dat","type","mergedTables"],"mappings":"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","file":"transformers.js","sourcesContent":["import _ from 'lodash';\nimport {TableModel} from './table_model';\n\nlet transformers = {};\n\ntransformers['table'] = {\n  description: 'Table',\n  getColumns: function(data) {\n    if (!data || data.length === 0) {\n      return [];\n    }\n\n    // Create a list containing the column names from each table\n    let columns = [];\n    _.forEach(data, (table) => {\n      columns.push(table.columns);\n    });\n    // Return the intersection of all column names only returning\n    // those that are present in each table\n    // NOTE: _.intersection([array]) should work here, but appears to be broken\n    return columns.shift().filter(function(v) {\n      return columns.every(function(a) {\n        return a.indexOf(v) !== -1;\n      });\n    });\n  },\n\n  transformTable: function(data, columnsToInclude) {\n    let model = new TableModel();\n\n    // Convert the rows to columns\n    let cellsByColumnIndex = [];\n    _.each(data.columns, col => cellsByColumnIndex.push([]));\n\n    // For every row\n    _.each(data.rows, row => {\n      // And every cell in the row\n      for (let i = 0; i < row.length; i++) {\n        // Append the cell to the appropriate column list\n        cellsByColumnIndex[i].push(row[i]);\n      }\n    });\n\n    // Now reorder the columns according the list of columns in the panel definition\n    let cellsByPanelColumnIndex = [];\n    for (let j = 0; j < columnsToInclude.length; j++) {\n      let colDef = columnsToInclude[j];\n      // Determine the column's index in the given data\n      let idx = _.findIndex(data.columns, col => {\n        return col === colDef.text || col.text === colDef.text;\n      });\n      if (idx < 0) {\n        throw {message: 'The column named \"' + colDef.text + '\" was specified in the panel definition,' +\n        ' but was not found in the given data. The available columns include: ' + JSON.stringify(data.columns)};\n      }\n      // Re-order\n      cellsByPanelColumnIndex[j] = cellsByColumnIndex[idx];\n    }\n\n    // Convert the columns back to rows\n    model.columns = columnsToInclude;\n    model.rows = [];\n    for (let k = 0; k < cellsByPanelColumnIndex[0].length; k++) {\n      let row = [];\n      for (let l = 0; l < columnsToInclude.length; l++) {\n        row.push(cellsByPanelColumnIndex[l][k]);\n      }\n      // Preserve the meta-data, if any\n      if (data.rows[k].meta !== undefined) {\n        row.meta = data.rows[k].meta;\n      }\n      model.rows.push(row);\n    }\n    return model;\n  },\n\n  mergeTables: function(tables) {\n    let model = new TableModel();\n    // Use the list of columns from the first table:\n    //  transformTable() will ensure that all tables have the same columns\n    model.columns = tables[0].columns;\n    // Concatenate the rows\n    _.each(tables, table => {\n      model.rows = _.concat(model.rows, table.rows);\n    });\n    // De-duplicate by (source, alarm.id) tuple\n    model.rows = _.uniqBy(model.rows, row => {\n      if (row.meta && row.meta.alarm) {\n        return JSON.stringify({\n          source: row.meta.source,\n          alarmId: row.meta.alarm.id\n        });\n      } else {\n        return row;\n      }\n    });\n    return model;\n  },\n\n  transform: function(data, panel, model) {\n    if (!data || data.length === 0) {\n      return;\n    }\n\n    // Determine the list of columns to include\n    let columnsToInclude = [];\n    if (panel.columns && panel.columns.length > 0) {\n      // One or more columns were specified in the column definition, use these\n      columnsToInclude = panel.columns;\n    } else {\n      // Use all the available columns\n      columnsToInclude = this.getColumns(data);\n    }\n\n    // Transform each of the datasource results individually\n    let transformedTables = [];\n    _.each(data, (dat) => {\n      if (dat.type !== 'table') {\n        throw {message: 'Query result is not in table format, try using another transform.'};\n      }\n      transformedTables.push(this.transformTable(dat, columnsToInclude));\n    });\n\n    // Merge the results and update the model\n    let mergedTables = this.mergeTables(transformedTables);\n    model.columns = mergedTables.columns;\n    model.rows = mergedTables.rows;\n  }\n};\n\nfunction transformDataToTable(data, panel) {\n  let model = new TableModel();\n\n  if (!data || data.length === 0) {\n    return model;\n  }\n\n  let transformer = transformers[panel.transform];\n  if (!transformer) {\n    throw {message: 'Transformer ' + panel.transform + ' not found'};\n  }\n\n  transformer.transform(data, panel, model);\n  return model;\n}\n\nexport {transformers, transformDataToTable};\n"]}